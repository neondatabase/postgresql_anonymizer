///
/// # Walker module
///
/// This module contains recursive function called "walkers" that will go
/// through a Postgres Tree object ( either a PlannerStmt or a Query )
///
/// ZomboDB is the main inspiration for this module
/// https://github.com/zombodb/zombodb/blob/v3000.2.5/src/walker/mod.rs
///
use crate::error;
use crate::masking;
use pgrx::*;
use std::ffi::c_char;
use std::ffi::CString;

pub struct PlanWalker {
    policy: String,
}

impl PlanWalker {
    pub fn new(policy: String) -> Self {
        PlanWalker {
            policy,
        }
    }

    pub fn rewrite(&mut self, query: &PgBox<pg_sys::Query>) {
        unsafe {
            pg_sys::query_tree_walker(
                query.as_ptr(),
                Some(rewrite_walker),
                self as *mut PlanWalker as void_mut_ptr,
                pg_sys::QTW_EXAMINE_RTES as i32,
            );
        }
    }
}

#[pg_guard]
unsafe extern "C" fn rewrite_walker(node: *mut pg_sys::Node, context_ptr: void_mut_ptr) -> bool {
    if node.is_null() {
        return false;
    }

    let context = PgBox::<PlanWalker>::from_pg(context_ptr as *mut PlanWalker);
    let policy = context.policy.clone();

    if is_a(node, pg_sys::NodeTag::T_RangeTblEntry) {
        // The node is a Range Table Entry
        let mut rte = PgBox::from_pg(node as *mut pg_sys::RangeTblEntry);
        debug1!("rte= {:?}",rte);

        // This is a subquery, continue to the next node
        if rte.relid == 0.into() { return false; }

        // Create a Masking Sub Query (msq) that will replace the relation
        let msq_sql = masking::subquery(rte.relid, policy);

        // This table is not masked, skip to the next node
        if msq_sql.is_none() { return false; }

        debug1!("msq_sql= {}",msq_sql.clone().unwrap());

        // Create the Raw Statement from the SQL subquery
        let msq_raw_stmt = masking::parse_subquery(msq_sql.clone().unwrap());
        debug1!("msq_raw_stmt= {:?}",*msq_raw_stmt);

        // Create the Parse State with the SQL subquery within
        let mut msq_pstate = unsafe {
            PgBox::from_pg(
                pg_sys::make_parsestate(
                    std::ptr::null_mut::<pg_sys::ParseState>()
                )
            )
        };
        let msq_sql_c_string = CString::new(msq_sql.clone().unwrap().as_str()).unwrap();
        let msq_sql_ptr = msq_sql_c_string.as_c_str().as_ptr() as *const c_char;
        msq_pstate.p_sourcetext = msq_sql_ptr;

        // Create the Query object
        // Calling parse_analyze_varparams(...) would trigger the
        // post_parse_analyze hook again and we'd stuck in an infinite loop
        let mut msq_query = unsafe {
            PgBox::from_pg(
                pg_sys::transformTopLevelStmt(
                    msq_pstate.as_ptr(),
                    msq_raw_stmt.as_ptr()
                )
            )
        };

        //
        // QSRC_PARSER is not used anymore by Postgres.
        // This is convenient because we can use it as a marker to signal
        // that this query was generated by the extension, and thus it should
        // NOT be masked otherwise we'd trapped in an infinite loop
        //
        msq_query.querySource = pg_sys::QuerySource::QSRC_PARSER;
        debug1!("new_subquery= {:?}",*msq_query);

        // Do the substitution
        pg_sys::AcquireRewriteLocks(msq_query.as_ptr(), true, false);
        rte.rtekind = pg_sys::RTEKind::RTE_SUBQUERY;
        rte.subquery = msq_query.as_ptr();
        rte.relid = pg_sys::InvalidOid;
        rte.relkind = 0;
        // TODO apply the table sampling ratio
        // rte.tablesample = ....;

        // Return the modified RTE to Postgres
        rte.into_pg();

        return false;
    } else if is_a(node, pg_sys::NodeTag::T_Query) {
        let query = PgBox::from_pg(node as *mut pg_sys::Query);

        // The query is a masking subquery
        // we don't need to apply the masks on it !
        if query.querySource == pg_sys::QuerySource::QSRC_PARSER {
            return false;
        }
        // Continue parsing the tree
        return pg_sys::query_tree_walker(
            node as *mut pg_sys::Query,
            Some(rewrite_walker),
            context_ptr,
            pg_sys::QTW_EXAMINE_RTES as i32,
        );
    } else if is_a(node, pg_sys::NodeTag::T_InsertStmt)
           || is_a(node, pg_sys::NodeTag::T_DeleteStmt)
           || is_a(node, pg_sys::NodeTag::T_UpdateStmt)
           || is_a(node, pg_sys::NodeTag::T_TruncateStmt)
           || is_a(node, pg_sys::NodeTag::T_CreateStmt)
           || is_a(node, pg_sys::NodeTag::T_DropStmt)
           || is_a(node, pg_sys::NodeTag::T_SecLabelStmt)
    {
        error::insufficient_privilege("role is masked".to_string()).ereport();
    }

    pg_sys::expression_tree_walker(node, Some(rewrite_walker), context_ptr)
}
